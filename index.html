<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS · SMOOTH PULSE</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  html, body { margin:0; padding:0; background:#000; overflow:hidden; height:100%; font-family:'Courier New', monospace; color:#0af; }
  canvas { display:block; }
  #hud { position:absolute; top:16px; left:16px; font-size:13px; opacity:0.7; pointer-events:none; letter-spacing:1px; }
  #data { position:absolute; bottom:16px; left:16px; font-size:10px; opacity:0.5; pointer-events:none; max-width:380px; line-height:1.4; }
  #data span.val { color:#8cf; font-weight:bold; }
  #clock { position:absolute; bottom:16px; right:16px; font-size:11px; opacity:0.45; color:#6cf; text-align:right; pointer-events:none; line-height:1.3; }
  #status { position:absolute; top:40px; left:16px; font-size:11px; opacity:0.6; color:#f93; }
</style>
</head>
<body>
<div id="hud">GEOMETRIC CHAOS — SMOOTH EARTH PULSE</div>
<div id="status">Дані: завантаження...</div>
<div id="data">Завантаження реальних даних...</div>
<div id="clock">—</div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dataDiv = document.getElementById('data');
const clockDiv = document.getElementById('clock');
const statusDiv = document.getElementById('status');

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

const startTime = Date.now();
function formatRelativeTime(ms) {
  const s = Math.floor(ms / 1000);
  if (s < 60) return `+${s}s`;
  const m = Math.floor(s / 60); const sec = s % 60;
  if (m < 60) return `+${m}m ${sec}s`;
  const h = Math.floor(m / 60); const min = m % 60;
  return `+${h}h ${min}m`;
}
function updateClock() {
  const now = new Date();
  clockDiv.innerHTML = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}<br>${formatRelativeTime(Date.now() - startTime)}`;
}
setInterval(updateClock, 1000); updateClock();

const stars = [];
for (let i = 0; i < 300; i++) {
  stars.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, size: Math.random()*1.4+0.4, baseAlpha: Math.random()*0.4+0.25, twinkle: Math.random()*0.015+0.006 });
}

let realData = { seismic:0.5, magnetic:0.5, atmosphere_wind:0.5, atmosphere_pressure:0.5, atmosphere_temp:0.5, ocean:0.5, solar_radiation:0.5, solar_wind:0.5, precipitation:0.5, chaos:0.5 };
let dataHistory = {}; Object.keys(realData).forEach(k => dataHistory[k] = []);

const blobs = [
  { param: 'seismic', color: 'rgba(220,60,80,', phase: 0.0, targetSize:6, targetAlpha:0.75 },
  { param: 'magnetic', color: 'rgba(60,180,255,', phase: 1.2, targetSize:6, targetAlpha:0.75 },
  { param: 'atmosphere_wind', color: 'rgba(80,255,160,', phase: 2.4, targetSize:6, targetAlpha:0.7 },
  { param: 'atmosphere_temp', color: 'rgba(255,180,60,', phase: 3.6, targetSize:6, targetAlpha:0.7 },
  { param: 'solar_radiation', color: 'rgba(255,240,100,', phase: 4.8, targetSize:5, targetAlpha:0.65 },
  { param: 'solar_wind', color: 'rgba(200,120,255,', phase: 6.0, targetSize:6, targetAlpha:0.7 },
  { param: 'precipitation', color: 'rgba(100,220,255,', phase: 7.2, targetSize:6, targetAlpha:0.7 }
];
blobs.forEach(b => { b.angle = Math.random()*Math.PI*2; b.radius = 60 + Math.random()*50; b.currentSize = b.targetSize; b.currentAlpha = b.targetAlpha; b.currentDist = b.radius; });

function lerp(a, b, t) { return a + (b - a) * t; }

async function fetchRealPlanetData() {
  statusDiv.innerHTML = 'Дані: завантаження...';
  try {
    // Open-Meteo (працює з браузера, CORS OK)
    const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=50.55&longitude=30.25&current=temperature_2m,wind_speed_10m,surface_pressure,precipitation,shortwave_radiation`;
    const wRes = await fetch(weatherUrl);
    if (!wRes.ok) throw new Error('Weather fail');
    const w = (await wRes.json()).current || {};

    realData.atmosphere_temp     = Math.min(1, Math.max(0, (w.temperature_2m + 40) / 80));
    realData.atmosphere_wind     = Math.min(1, (w.wind_speed_10m || 0) / 80);
    realData.atmosphere_pressure = Math.min(1, Math.max(0, ((w.surface_pressure || 1013) - 950) / 150));
    realData.precipitation       = Math.min(1, (w.precipitation || 0) / 15);
    realData.solar_radiation     = Math.min(1, (w.shortwave_radiation || 0) / 1200);

    // Marine API (CORS OK)
    const oceanRes = await fetch(`https://marine-api.open-meteo.com/v1/marine?latitude=44.5&longitude=34.0&current=wave_height`);
    const o = (await oceanRes.json()).current || {};
    realData.ocean = Math.min(1, (o.wave_height || 0) / 8);

    // USGS (CORS дозволений)
    const eqRes = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson');
    const eq = await eqRes.json();
    const feats = eq.features || [];
    const count = feats.length;
    const maxMag = feats.reduce((m, f) => Math.max(m, f.properties?.mag || 0), 0);
    realData.seismic = Math.min(1, (count / 30) + (maxMag / 10) * 0.5);

    // NOAA не працює → фолбек на випадкове або фіксоване
    realData.solar_wind = Math.random() * 0.4 + 0.3; // або фікс 0.5
    realData.magnetic   = Math.random() * 0.3 + 0.2;

    // Історія + chaos
    Object.keys(realData).forEach(k => {
      if (k !== 'chaos') {
        dataHistory[k].push(realData[k]);
        if (dataHistory[k].length > 80) dataHistory[k].shift();
      }
    });

    let vars = [];
    Object.keys(dataHistory).forEach(k => {
      if (k === 'chaos') return;
      const h = dataHistory[k];
      if (h.length < 2) return;
      const mean = h.reduce((a,b)=>a+b,0)/h.length;
      const varnce = h.reduce((a,b)=>a+(b-mean)**2,0)/h.length;
      vars.push(Math.sqrt(varnce));
    });
    realData.chaos = vars.length ? Math.min(1, vars.reduce((a,b)=>a+b,0)/vars.length * 10) : 0.5;

    blobs.forEach(b => {
      const v = realData[b.param] || 0.5;
      b.targetSize = 4 + v * 14;
      b.targetAlpha = 0.3 + v * 0.6;
      b.targetDist = 70 + v * 80;
    });

    dataDiv.innerHTML = Object.keys(realData).map(k => `${k.padEnd(20,' ')} <span class="val">${realData[k].toFixed(3)}</span>`).join('<br>');
    statusDiv.innerHTML = 'Дані: ОК (частково реальні)';

  } catch (e) {
    console.error('Fetch error:', e);
    statusDiv.innerHTML = 'Дані: помилка → випадкові';
    Object.keys(realData).forEach(k => { if (k !== 'chaos') realData[k] = Math.random()*0.6 + 0.2; });
  }
}

fetchRealPlanetData();
setInterval(fetchRealPlanetData, 60000); // 60 секунд

// Анімація (без змін)
let t = 0;
function loop() {
  t += 0.016;
  ctx.fillStyle = 'rgba(0,0,0,0.07)'; ctx.fillRect(0,0,canvas.width,canvas.height);

  const chaos = realData.chaos;
  const starMod = 1 - chaos * 0.35;
  stars.forEach(s => {
    const tw = Math.sin(t * s.twinkle * 12 + s.x * 0.008) * 0.18 * starMod;
    ctx.fillStyle = `rgba(220,235,255,${Math.max(0.08, s.baseAlpha + tw).toFixed(3)})`;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  });

  const cx = canvas.width/2, cy = canvas.height/2;
  const smooth = 0.04 + chaos * 0.10;
  const avg = blobs.reduce((s,b)=>s + (realData[b.param]||0.5), 0) / blobs.length;

  blobs.forEach(b => {
    b.currentSize  = lerp(b.currentSize, b.targetSize, smooth);
    b.currentAlpha = lerp(b.currentAlpha, b.targetAlpha, smooth*1.2);
    b.currentDist  = lerp(b.currentDist, b.targetDist, smooth*0.8);

    const pulse = Math.sin(t*0.7 + b.phase)*0.15 + Math.sin(t*1.3 + b.phase*1.4)*0.09 + Math.sin(t*2.1 + b.phase*0.7)*0.06*chaos;
    const size = b.currentSize * (1 + pulse * (0.4 + chaos*0.9));

    b.angle += (0.008 + avg*0.03 + chaos*0.04) * (1 + pulse*0.3);

    const x = cx + Math.cos(b.angle)*b.currentDist;
    const y = cy + Math.sin(b.angle)*b.currentDist;

    ctx.fillStyle = b.color + (b.currentAlpha + pulse*0.25).toFixed(2) + ')';
    ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill();
  });

  const ringBase = 110 + Math.sin(t*0.25)*18 + Math.sin(t*0.48)*12;
  const ringR = ringBase * (1 + chaos*0.35 + Math.sin(t*0.9)*0.08);
  ctx.beginPath(); ctx.arc(cx,cy,ringR,0,Math.PI*2);
  ctx.strokeStyle = `rgba(140,240,255,${0.06 + chaos*0.18 + Math.sin(t*1.1)*0.04})`;
  ctx.lineWidth = 1.4 + chaos*3.2; ctx.stroke();

  ctx.beginPath(); ctx.arc(cx,cy,ringR*0.45,0,Math.PI*2);
  ctx.fillStyle = `rgba(100,200,255,${0.02 + chaos*0.10 + Math.sin(t*0.7)*0.03})`; ctx.fill();

  // Геометрія (залишив)
  for (let i=0; i<5; i++) {
    const r = ringR*(0.8 + i*0.1) + realData.seismic*20*Math.sin(t*0.3 + i);
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.strokeStyle = `rgba(255,100,100,${0.03 + chaos*0.05})`; ctx.lineWidth = 0.8 + realData.magnetic*2; ctx.stroke();
  }

  ctx.strokeStyle = `rgba(200,255,255,${0.02 + chaos*0.08})`; ctx.lineWidth = 0.5;
  blobs.forEach(b => {
    const x = cx + Math.cos(b.angle)*b.currentDist;
    const y = cy + Math.sin(b.angle)*b.currentDist;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(x,y); ctx.stroke();
  });

  const sides = 3 + Math.floor(chaos*5);
  const polyR = ringR*1.2 + realData.solar_radiation*30;
  ctx.beginPath();
  for (let i=0; i<sides; i++) {
    const ang = (Math.PI*2/sides)*i + t*0.1;
    const px = cx + Math.cos(ang)*polyR;
    const py = cy + Math.sin(ang)*polyR;
    i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle = `rgba(255,200,100,${0.04 + realData.solar_wind*0.1})`; ctx.stroke();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

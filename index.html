<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <title>GEOMETRIC CHAOS x PLANET CHAOS · ARCHIVE 2026</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* ------------------------------------------------------------------
           CORE STYLES (MERGED)
           ------------------------------------------------------------------ */
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000;
            height: 100%;
            font-family: 'Courier New', monospace;
            color: #0af;
            overflow: hidden;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI CONTAINER */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .interactive {
            pointer-events: auto;
        }

        /* HEADER & HUD */
        #hud {
            position: absolute;
            top: 16px;
            left: 16px;
            font-size: 13px;
            opacity: 0.8;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(0, 170, 255, 0.5);
            font-weight: bold;
        }

        #hud-sub {
            position: absolute;
            top: 32px;
            left: 16px;
            font-size: 11px;
            opacity: 0.6;
            color: #6cf;
        }

        #status {
            position: absolute;
            top: 50px;
            left: 16px;
            font-size: 11px;
            color: #0f0;
            opacity: 0.7;
        }

        /* CODE 2: MONTHS NAV */
        #months-nav {
            position: absolute;
            top: 80px;
            left: 16px;
            width: 100px;
            font-size: 12px;
            line-height: 1.8;
        }

        #months-nav a {
            display: block;
            color: #0af;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
        }

        #months-nav a:hover {
            color: #fff;
            text-shadow: 0 0 5px #0af;
        }

        /* CODE 2: MAIN DATA LIST */
        #data-main {
            position: absolute;
            top: 80px;
            left: 130px;
            bottom: 20px;
            width: 400px;
            font-size: 11px;
            line-height: 1.0;
            letter-spacing: -0.5px;
            overflow-y: auto;
            color: #0f0;
            display: grid;
            grid-template-columns: auto auto;
            align-content: start;
            justify-content: start;
            column-gap: 25px;
            row-gap: 0px;
            padding-right: 15px;
            scrollbar-width: thin;
            scrollbar-color: #004466 #001122;
        }

        /* HEATMAP (Square block near the top graph) */
        #heatmap {
            position: absolute;
            top: 80px;
            right: 240px;
            /* Moved further left from graphs */
            display: grid;
            grid-template-columns: repeat(8, 14px);
            gap: 2px;
            opacity: 0.9;
            pointer-events: none;
        }

        .heatcell {
            width: 14px;
            height: 14px;
            background: #0f0;
            border: 1px solid #333;
        }

        /* FOOTER */
        #clock {
            position: absolute;
            bottom: 16px;
            right: 16px;
            font-size: 11px;
            opacity: 0.5;
            color: #6cf;
            text-align: right;
            line-height: 1.3;
        }

        /* DATA STYLING */
        .category {
            margin: 8px 0 4px 0;
            font-size: 12px;
            color: #0af;
            font-weight: bold;
            grid-column: span 2;
            border-bottom: 2px solid #004466;
            padding-bottom: 2px;
            text-transform: uppercase;
        }

        .row {
            white-space: pre;
            opacity: 0.9;
            margin-bottom: 1px;
        }

        .label {
            color: #6cf;
        }

        .val {
            font-weight: bold;
        }

        .val-safe {
            color: #0f0;
        }

        .val-watch {
            color: #ffd700;
        }

        .val-warn {
            color: #ff8c00;
        }

        .val-danger {
            color: #f00;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #001122;
        }

        ::-webkit-scrollbar-thumb {
            background: #004466;
        }

        @media (max-width: 800px) {
            #months-nav {
                top: 70px;
                left: 16px;
                width: 100%;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                height: auto;
            }

            #data-main {
                top: 200px;
                left: 16px;
                right: 16px;
                width: auto;
                grid-template-columns: 1fr;
                background: rgba(0, 0, 0, 0.7);
                padding: 10px;
            }

            #heatmap {
                top: 50px;
                left: 16px;
                right: 16px;
                grid-template-columns: repeat(auto-fill, 14px);
                /* Responsive on mobile */
                width: auto;
            }

            #hud {
                font-size: 12px;
            }
        }
    </style>
</head>

<body>

    <canvas id="c"></canvas>

    <div id="ui-layer">
        <div id="hud">ARCHIVE 2026.lavanda.audit.</div>
        <div id="hud-sub">lavanda audit · ibonarium · project 2026</div>
        <div id="status">ініціалізація...</div>

        <!-- HEATMAP AT TOP -->
        <div id="heatmap"></div>

        <div id="months-nav" class="interactive">
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">JANUARY</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">FEBRUARY</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">MARCH</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">APRIL</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">MAY</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">JUNE</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">JULY</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">AUGUST</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">SEPTEMBER</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">OCTOBER</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">NOVEMBER</a>
            <a href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#">DECEMBER</a>
        </div>

        <div id="data-main" class="interactive"></div>
        <div id="clock">—</div>
    </div>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const dataDiv = document.getElementById('data-main');
        const statusDiv = document.getElementById('status');
        const clockDiv = document.getElementById('clock');
        const heatmapDiv = document.getElementById('heatmap');

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize); resize();

        const startTime = Date.now();
        function formatRelativeTime(ms) {
            const s = Math.floor(ms / 1000);
            if (s < 60) return `+${s}s`;
            const m = Math.floor(s / 60); const sec = s % 60;
            if (m < 60) return `+${m}m ${sec}s`;
            const h = Math.floor(m / 60); const min = m % 60;
            return `+${h}h ${min}m`;
        }
        function updateClock() {
            const now = new Date();
            clockDiv.innerHTML = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}<br>${formatRelativeTime(Date.now() - startTime)}`;
        }
        setInterval(updateClock, 1000); updateClock();

        const proxy = 'https://corsproxy.io/?';

        let realData = { seismic: 0.5, magnetic: 0.5, atmosphere_wind: 0.5, atmosphere_pressure: 0.5, atmosphere_temp: 0.5, ocean: 0.5, solar_radiation: 0.5, solar_wind: 0.5, precipitation: 0.5, chaos: 0.5 };
        let solarIndices = { f107: 120, kp: 2.0, ap: 12, dst: -15, ssn: 85, xray: -6.5, proton: 0.3, electron: 150, bz: -2.5, density: 5.2 };
        let earthEnvData = { air_quality_pm25: 15, air_quality_aqi: 45, co: 0.4, no2: 25, o3: 40, so2: 10, uv_index: 3.5, humidity: 65, cloud_cover: 45, visibility: 12 };

        let dataHistory = {}; Object.keys(realData).forEach(k => dataHistory[k] = []);
        let heatmapValues = [];

        const stars = [];
        for (let i = 0; i < 300; i++) stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 1.2 + 0.4, baseAlpha: Math.random() * 0.4 + 0.25, twinkle: Math.random() * 0.015 + 0.006 });

        const blobs = [
            { param: 'seismic', color: 'rgba(220,60,80,', phase: 0 },
            { param: 'magnetic', color: 'rgba(60,180,255,', phase: 1.2 },
            { param: 'atmosphere_wind', color: 'rgba(80,255,160,', phase: 2.4 },
            { param: 'atmosphere_temp', color: 'rgba(255,180,60,', phase: 3.6 },
            { param: 'solar_radiation', color: 'rgba(255,240,100,', phase: 4.8 },
            { param: 'solar_wind', color: 'rgba(200,120,255,', phase: 6.0 },
            { param: 'precipitation', color: 'rgba(100,220,255,', phase: 7.2 }
        ];
        blobs.forEach(b => {
            b.targetSize = 6; b.targetAlpha = 0.7; b.angle = Math.random() * 6.28; b.radius = 60 + Math.random() * 50;
            b.currentSize = b.targetSize; b.currentAlpha = b.targetAlpha; b.currentDist = b.radius;
        });

        const formulas = ["E=mc^2", "F=ma", "∇·E=ρ/ε₀", "∫F·dr=ΔK", "a^2+b^2=c^2", "iħ∂ψ/∂t=Hψ", "V=IR"];
        const formulaObjs = formulas.map(f => ({ text: f, x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, alpha: 0, phase: Math.random() * 6.28 }));

        function lerp(a, b, t) { return a + (b - a) * t; }

        function getColorClass(value, thresholds) {
            if (value === '--' || value === null) return 'val-safe';
            if (!thresholds) return 'val-safe';
            let v = parseFloat(value);
            if (isNaN(v)) return 'val-safe';
            if (thresholds.danger !== undefined && v >= thresholds.danger) return 'val-danger';
            if (thresholds.warn !== undefined && v >= thresholds.warn) return 'val-warn';
            if (thresholds.watch !== undefined && v >= thresholds.watch) return 'val-watch';
            return 'val-safe';
        }
        function getColor(value, thresholds) {
            const cls = getColorClass(value, thresholds);
            switch (cls) {
                case 'val-safe': return '#0f0';
                case 'val-watch': return '#ffd700';
                case 'val-warn': return '#ff8c00';
                case 'val-danger': return '#f00';
                default: return '#0f0';
            }
        }
        function updateHeatmap() {
            heatmapDiv.innerHTML = '';
            heatmapValues.forEach(val => {
                const cell = document.createElement('div');
                cell.className = 'heatcell';
                cell.style.background = val.color;
                heatmapDiv.appendChild(cell);
            });
        }
        async function fetchSmart(url) {
            try { let r = await fetch(url); if (r.ok) return await r.json(); } catch (e) { }
            try { let r = await fetch(proxy + encodeURIComponent(url)); if (r.ok) return await r.json(); } catch (e) { }
            return null;
        }
        async function fetchWithProxy(url) {
            try { let r = await fetch(proxy + encodeURIComponent(url)); if (r.ok) return await r.json(); } catch (e) { }
            return null;
        }

        async function fetchAllData() {
            statusDiv.innerHTML = 'оновлення джерел...';
            let html = '';
            let loaded = 0;
            heatmapValues = []; // Clear for new cycle

            // --- 1. WEATHER ---
            html += '<div class="category">ПОГОДА (KYIV)</div>';
            const weather = await fetchSmart('https://api.open-meteo.com/v1/forecast?latitude=50.45&longitude=30.52&current=temperature_2m,relative_humidity_2m,pressure_msl,wind_speed_10m,wind_direction_10m,precipitation,weather_code,is_day,shortwave_radiation,visibility');
            if (weather?.current) {
                const w = weather.current;
                realData.atmosphere_temp = Math.min(1, Math.max(0, (w.temperature_2m + 40) / 80));
                realData.atmosphere_wind = Math.min(1, (w.wind_speed_10m || 0) / 80);
                realData.atmosphere_pressure = Math.min(1, Math.max(0, ((w.pressure_msl || 1013) - 950) / 150));
                realData.precipitation = Math.min(1, (w.precipitation || 0) / 15);
                realData.solar_radiation = Math.min(1, (w.shortwave_radiation || 0) / 1200);
                earthEnvData.humidity = w.relative_humidity_2m || 65;
                earthEnvData.cloud_cover = 45;
                earthEnvData.visibility = (w.visibility || 12000) / 1000;

                const wMetrics = [
                    { label: 'Temperature', value: w.temperature_2m, thresholds: { watch: 30, warn: 35, danger: 40 }, unit: ' °C' },
                    { label: 'Humidity', value: w.relative_humidity_2m, thresholds: { watch: 80, warn: 90, danger: 95 }, unit: ' %' },
                    { label: 'Pressure', value: w.pressure_msl, thresholds: { watch: 1020, warn: 1030, danger: 1040 }, unit: ' hPa' },
                    { label: 'Wind Speed', value: w.wind_speed_10m, thresholds: { watch: 15, warn: 20, danger: 25 }, unit: ' km/h' },
                    { label: 'Precipitation', value: w.precipitation, thresholds: { watch: 1, warn: 5, danger: 10 }, unit: ' mm' },
                ];
                wMetrics.forEach(m => {
                    html += `<div class="row"><span class="label">${m.label} </span><span class="val ${getColorClass(m.value, m.thresholds)}">${m.value}${m.unit}</span></div>`;
                    heatmapValues.push({ value: m.value, color: getColor(m.value, m.thresholds) });
                });
                loaded += wMetrics.length;
            }

            // --- 2. AIR ---
            html += '<div class="category">ПОВІТРЯ (ENV)</div>';
            const air = await fetchSmart('https://air-quality-api.open-meteo.com/v1/air-quality?latitude=50.45&longitude=30.52&current=pm10,pm2_5,carbon_monoxide,ozone,european_aqi,nitrogen_dioxide,sulphur_dioxide,aerosol_optical_depth,dust,uv_index,alder_pollen,birch_pollen,grass_pollen,mugwort_pollen,olive_pollen,ragweed_pollen');
            if (air?.current) {
                const a = air.current;
                earthEnvData.air_quality_pm25 = a.pm2_5 || 15;
                earthEnvData.co = a.carbon_monoxide ? a.carbon_monoxide / 1000 : 0.4;
                earthEnvData.no2 = a.nitrogen_dioxide || 25;
                earthEnvData.o3 = a.ozone || 40;
                earthEnvData.so2 = a.sulphur_dioxide || 10;
                earthEnvData.air_quality_aqi = a.european_aqi || 50;
                earthEnvData.uv_index = a.uv_index || 3;

                const airMetrics = [
                    { label: 'European AQI', value: a.european_aqi, thresholds: { watch: 51, warn: 101, danger: 151 } },
                    { label: 'PM10', value: a.pm10, thresholds: { watch: 46, warn: 121, danger: 196 }, unit: ' µg/m³' },
                    { label: 'PM2.5', value: a.pm2_5, thresholds: { watch: 16, warn: 51, danger: 91 }, unit: ' µg/m³' },
                    { label: 'CO', value: a.carbon_monoxide ? (a.carbon_monoxide / 1000).toFixed(2) : null, thresholds: { watch: 5, warn: 10, danger: 20 }, unit: ' mg/m³' },
                    { label: 'O₃', value: a.ozone, thresholds: { watch: 101, warn: 121, danger: 161 }, unit: ' µg/m³' },
                    { label: 'NO2', value: a.nitrogen_dioxide, thresholds: { watch: 40, warn: 90, danger: 120 }, unit: ' µg/m³' },
                    { label: 'SO2', value: a.sulphur_dioxide, thresholds: { watch: 20, warn: 80, danger: 100 }, unit: ' µg/m³' },
                    { label: 'UV Index', value: a.uv_index, thresholds: { watch: 3, warn: 6, danger: 8 }, unit: '' },
                    { label: 'Pollen(Birch)', value: a.birch_pollen, thresholds: { watch: 10, warn: 50, danger: 100 }, unit: ' gr/m³' },
                    { label: 'Pollen(Grass)', value: a.grass_pollen, thresholds: { watch: 10, warn: 50, danger: 100 }, unit: ' gr/m³' },
                    { label: 'Pollen(Ambrosia)', value: a.ragweed_pollen, thresholds: { watch: 10, warn: 50, danger: 100 }, unit: ' gr/m³' }
                ];
                airMetrics.forEach(m => {
                    html += `<div class="row"><span class="label">${m.label} </span><span class="val ${getColorClass(m.value, m.thresholds)}">${m.value ?? '--'}${m.unit ?? ''}</span></div>`;
                    heatmapValues.push({ value: m.value, color: getColor(m.value, m.thresholds) });
                });
                loaded += airMetrics.length;
            }

            // --- 3. COSMOS ---
            html += '<div class="category">КОСМОС (SOLAR)</div>';
            const plasma = await fetchWithProxy('https://services.swpc.noaa.gov/products/solar-wind/plasma-7-day.json');
            if (plasma?.length > 1) {
                let lastValid = plasma.slice().reverse().find(r => !isNaN(parseFloat(r[3])) && parseFloat(r[3]) > 0);
                if (lastValid) {
                    const speed = parseFloat(lastValid[3]);
                    const den = parseFloat(lastValid[6]);
                    const bz = parseFloat(lastValid[8]);
                    realData.solar_wind = Math.min(1, Math.max(0, (speed - 250) / 750));
                    solarIndices.density = den;
                    solarIndices.bz = bz;

                    const plasmaMetrics = [
                        { label: 'Solar Wind Speed', value: speed, thresholds: { watch: 500, warn: 700, danger: 900 }, unit: ' km/s' },
                        { label: 'Solar Wind Density', value: den, thresholds: { watch: 15, warn: 30, danger: 50 }, unit: ' /cm³' },
                        { label: 'Solar Wind Temp', value: parseFloat(lastValid[7]) / 1000, thresholds: { watch: 100, warn: 300, danger: 500 }, unit: ' kK' },
                        { label: 'Mag Field Bt', value: parseFloat(lastValid[2]), thresholds: { watch: 5, warn: 10, danger: 20 }, unit: ' nT' },
                        { label: 'Mag Field Bz', value: bz, thresholds: { watch: 5, warn: 10, danger: 20 }, unit: ' nT' }
                    ];
                    plasmaMetrics.forEach(m => {
                        html += `<div class="row"><span class="label">${m.label} </span><span class="val ${getColorClass(m.value, m.thresholds)}">${m.value.toFixed(1)}${m.unit}</span></div>`;
                        heatmapValues.push({ value: m.value, color: getColor(m.value, m.thresholds) });
                    });
                    loaded += plasmaMetrics.length;
                }
            }

            const kpData = await fetchWithProxy('https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json');
            if (kpData?.length) {
                const lastKp = parseFloat(kpData[kpData.length - 1][1]) || 0;
                solarIndices.kp = lastKp;
                html += `<div class="row"><span class="label">Kp-index </span><span class="val ${getColorClass(lastKp, { watch: 5, warn: 6, danger: 7 })}">${lastKp}</span></div>`;
                heatmapValues.push({ value: lastKp, color: getColor(lastKp, { watch: 5, warn: 6, danger: 7 }) });
                for (let i = 2; i <= 4; i++) {
                    let val = parseFloat(kpData[kpData.length - i][1]) || 0;
                    html += `<div class="row"><span class="label">Kp T-${i - 1} </span><span class="val ${getColorClass(val, { watch: 5, warn: 6, danger: 7 })}">${val}</span></div>`;
                    heatmapValues.push({ value: val, color: getColor(val, { watch: 5, warn: 6, danger: 7 }) });
                }
            }

            const dst = await fetchWithProxy('https://services.swpc.noaa.gov/products/kyoto-dst.json');
            if (dst?.length > 0) {
                const lastDst = parseFloat(dst[dst.length - 1][1]) || 0;
                solarIndices.dst = lastDst;
                html += `<div class="row"><span class="label">Dst Index </span><span class="val ${getColorClass(-lastDst, { watch: 50, warn: 100, danger: 200 })}">${lastDst} nT</span></div>`;
                heatmapValues.push({ value: lastDst, color: getColor(-lastDst, { watch: 50, warn: 100, danger: 200 }) });
            }

            const xray = await fetchWithProxy('https://services.swpc.noaa.gov/json/goes/primary/xray-flares-latest.json');
            if (xray?.length > 0) {
                const fluxVal = xray[0].flux || 0;
                html += `<div class="row"><span class="label">X-ray Flare </span><span class="val">${fluxVal} ${xray[0].class_type ?? ''}</span></div>`;
                heatmapValues.push({ value: fluxVal, color: '#ffd700' });
            }

            const sunspots = await fetchWithProxy('https://services.swpc.noaa.gov/json/solar-cycle/predicted-solar-cycle.json');
            if (sunspots && sunspots.length > 0) {
                const val = sunspots[sunspots.length - 1]['predicted_sunspot_number'];
                html += `<div class="row"><span class="label">Sunspot Num </span><span class="val">${val}</span></div>`;
                heatmapValues.push({ value: val, color: '#ffd700' });
            }

            const proton = await fetchWithProxy('https://services.swpc.noaa.gov/json/goes/primary/integral-protons-1-day.json');
            if (proton && proton.length > 0) {
                const val = parseFloat(proton[proton.length - 1].flux);
                html += `<div class="row"><span class="label">Proton Flux </span><span class="val ${getColorClass(val, { watch: 10, warn: 100, danger: 1000 })}">${val.toExponential(1)}</span></div>`;
                heatmapValues.push({ value: val, color: getColor(val, { watch: 10, warn: 100, danger: 1000 }) });
            }

            const electron = await fetchWithProxy('https://services.swpc.noaa.gov/json/goes/primary/integral-electrons-1-day.json');
            if (electron && electron.length > 0) {
                const val = parseFloat(electron[electron.length - 1].flux);
                html += `<div class="row"><span class="label">Electron Flux </span><span class="val ${getColorClass(val, { watch: 1000, warn: 10000, danger: 100000 })}">${val.toExponential(1)}</span></div>`;
                heatmapValues.push({ value: val, color: getColor(val, { watch: 1000, warn: 10000, danger: 100000 }) });
            }

            // --- 4. WATER ---
            html += '<div class="category">ВОДА (GLOBAL)</div>';
            const waterPoints = [
                { name: 'Black Sea', lat: 43.0, lon: 34.0 }, { name: 'Mediterranean', lat: 35.0, lon: 18.0 }, { name: 'North Atlantic', lat: 45.0, lon: -30.0 }, { name: 'Pacific Ocean', lat: 20.0, lon: -155.0 }
            ];
            for (const wp of waterPoints) {
                const wData = await fetchSmart(`https://marine-api.open-meteo.com/v1/marine?latitude=${wp.lat}&longitude=${wp.lon}&current=wave_height,sea_surface_temperature`);
                if (wData?.current) {
                    const wm = wData.current;
                    html += `<div class="row"><span class="label">${wp.name} </span><span class="val">${wm.sea_surface_temperature}°C / ${wm.wave_height}m</span></div>`;
                    heatmapValues.push({ value: wm.sea_surface_temperature, color: getColor(wm.sea_surface_temperature, { watch: 25, warn: 30, danger: 32 }) });
                    loaded++;
                }
            }

            // --- 5. ENERGY ---
            html += '<div class="category">ЕНЕРГІЯ (YAHOO)</div>';
            const commodities = [
                { symbol: 'CL=F', name: 'WTI Oil' }, { symbol: 'BZ=F', name: 'Brent Oil' }, { symbol: 'NG=F', name: 'Nat. Gas' }, { symbol: 'GC=F', name: 'Gold' }, { symbol: 'SI=F', name: 'Silver' }, { symbol: 'HG=F', name: 'Copper' }
            ];
            for (const c of commodities) {
                const dat = await fetchWithProxy(`https://query1.finance.yahoo.com/v8/finance/chart/${c.symbol}?range=1d&interval=1d`);
                if (dat?.chart?.result?.[0]?.meta?.regularMarketPrice) {
                    const val = dat.chart.result[0].meta.regularMarketPrice;
                    html += `<div class="row"><span class="label">${c.name} </span><span class="val">${val.toFixed(2)} $</span></div>`;
                    heatmapValues.push({ value: val, color: '#0f0' });
                    loaded++;
                }
            }

            // --- 6. AGRO ---
            html += '<div class="category">АГРО (YAHOO)</div>';
            const agro = [
                { symbol: 'ZC=F', name: 'Corn' }, { symbol: 'ZW=F', name: 'Wheat' }, { symbol: 'ZS=F', name: 'Soybean' }, { symbol: 'KC=F', name: 'Coffee' }
            ];
            for (const c of agro) {
                const dat = await fetchWithProxy(`https://query1.finance.yahoo.com/v8/finance/chart/${c.symbol}?range=1d&interval=1d`);
                if (dat?.chart?.result?.[0]?.meta?.regularMarketPrice) {
                    const val = dat.chart.result[0].meta.regularMarketPrice;
                    html += `<div class="row"><span class="label">${c.name} </span><span class="val">${val.toFixed(2)}</span></div>`;
                    heatmapValues.push({ value: val, color: '#ffd700' });
                    loaded++;
                }
            }

            // --- 7. EARTHQUAKES ---
            html += '<div class="category">ЗЕМЛЕТРУСИ (LAST HR)</div>';
            const quakes = await fetchSmart('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson');
            if (quakes?.features) {
                quakes.features.slice(0, 8).forEach((q) => {
                    const mag = q.properties.mag || 0;
                    const place = (q.properties.place || 'Unknown').substring(0, 18);
                    html += `<div class="row"><span class="label">M${mag.toFixed(1)} </span><span class="val ${getColorClass(mag, { watch: 4, warn: 5, danger: 6 })}">${place}</span></div>`;
                    heatmapValues.push({ value: mag, color: getColor(mag, { watch: 4, warn: 5, danger: 6 }) });
                });
                loaded++;
            }

            // --- 8. FINANCE & CRYPTO ---
            html += '<div class="category">CRYPTO & MARKET</div>';
            const cryptoIds = 'bitcoin,ethereum,solana,ripple,cardano';
            const crypto = await fetchWithProxy(`https://api.coingecko.com/api/v3/simple/price?ids=${cryptoIds}&vs_currencies=usd`);
            if (crypto) {
                for (let k in crypto) {
                    html += `<div class="row"><span class="label">${k.toUpperCase()} </span><span class="val">${crypto[k].usd} $</span></div>`;
                    heatmapValues.push({ value: 1, color: '#0f0' });
                }
            }
            const sp500 = await fetchSmart('https://query1.finance.yahoo.com/v8/finance/chart/^GSPC?range=1d&interval=1d');
            if (sp500?.chart?.result?.[0]?.meta?.regularMarketPrice) {
                const val = sp500.chart.result[0].meta.regularMarketPrice;
                html += `<div class="row"><span class="label">S&P 500 </span><span class="val">${val.toFixed(2)}</span></div>`;
                heatmapValues.push({ value: val, color: '#0f0' });
            }

            // --- 9. CURRENCIES ---
            html += '<div class="category">ВАЛЮТИ</div>';
            const cbRates = await fetchWithProxy('https://api.coinbase.com/v2/exchange-rates?currency=USD');
            if (cbRates?.data?.rates) {
                const r = cbRates.data.rates;
                ['EUR', 'GBP', 'JPY', 'UAH'].forEach(c => {
                    const val = parseFloat(r[c]);
                    html += `<div class="row"><span class="label">USD/${c} </span><span class="val">${val.toFixed(2)}</span></div>`;
                    heatmapValues.push({ value: val, color: '#0f0' });
                });
            }

            dataDiv.innerHTML = html || '<div>немає даних</div>';
            statusDiv.innerHTML = `джерела: ${loaded} • ${new Date().toLocaleTimeString()}`;
            updateHeatmap();
        }

        fetchAllData();
        setInterval(fetchAllData, 60000);

        // --- DRAWING FUNCTIONS ---
        function drawCombinedGrid() {
            if (canvas.width < 900) return;
            const w = 180, h = 100, mx = canvas.width - w - 20, my = 80;
            ctx.save(); ctx.translate(mx, my);
            ctx.strokeStyle = 'rgba(180,180,180,0.15)'; ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                let y = i * h / 5; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                let x = i * w / 5; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
            }
            ctx.fillStyle = 'rgba(0,255,180,0.8)'; ctx.font = '10px Courier New'; ctx.fillText('MAIN INDICES', 0, -5);
            const keys = Object.keys(realData).filter(k => k !== 'chaos');
            ctx.beginPath(); let f = true;
            keys.forEach((k, i) => {
                const v = realData[k]; const x = i * (w / (keys.length - 1)); const y = h - v * h;
                f ? ctx.moveTo(x, y) : ctx.lineTo(x, y); f = false;
            });
            ctx.strokeStyle = 'rgba(0,255,180,0.7)'; ctx.lineWidth = 1.8; ctx.stroke();
            keys.forEach((k, i) => {
                const v = realData[k]; const x = i * (w / (keys.length - 1)); const y = h - v * h;
                ctx.beginPath(); ctx.arc(x, y, 3, 0, 6.28); ctx.fillStyle = 'rgba(0,255,180,0.9)'; ctx.fill();
            });
            ctx.restore();
        }

        function drawSolarGrid() {
            if (canvas.width < 900) return;
            const w = 180, h = 100, mx = canvas.width - w - 20, my = 220;
            ctx.save(); ctx.translate(mx, my);
            ctx.strokeStyle = 'rgba(255,180,0,0.15)'; ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                let y = i * h / 5; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                let x = i * w / 5; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
            }
            ctx.fillStyle = 'rgba(255,220,80,0.8)'; ctx.font = '10px Courier New'; ctx.fillText('SOLAR INDICES', 0, -5);
            const keys = Object.keys(solarIndices);
            ctx.beginPath(); let f = true;
            keys.forEach((k, i) => {
                let v = solarIndices[k];
                if (k === 'f107') v /= 250; else if (k === 'kp') v /= 9; else if (k === 'dst') v = (v + 100) / 200;
                else if (k === 'proton' || k === 'electron') v = Math.log10(v + 1) / 5;
                else if (k === 'xray') v = (v + 8) / 6; else v /= 100;
                v = Math.max(0, Math.min(1, v));
                const x = i * (w / (keys.length - 1)); const y = h - v * h;
                f ? ctx.moveTo(x, y) : ctx.lineTo(x, y); f = false;
            });
            ctx.strokeStyle = 'rgba(255,220,80,0.7)'; ctx.lineWidth = 1.8; ctx.stroke();
            keys.forEach((k, i) => {
                let v = solarIndices[k];
                if (k === 'f107') v /= 250; else if (k === 'kp') v /= 9; else if (k === 'dst') v = (v + 100) / 200;
                else if (k === 'proton' || k === 'electron') v = Math.log10(v + 1) / 5;
                else if (k === 'xray') v = (v + 8) / 6; else v /= 100;
                v = Math.max(0, Math.min(1, v));
                const x = i * (w / (keys.length - 1)); const y = h - v * h;
                ctx.beginPath(); ctx.arc(x, y, 3, 0, 6.28); ctx.fillStyle = 'rgba(255,220,80,0.9)'; ctx.fill();
            });
            ctx.restore();
        }

        function drawEarthEnvGrid() {
            if (canvas.width < 900) return;
            const w = 180, h = 100, mx = canvas.width - w - 20, my = 360;
            ctx.save(); ctx.translate(mx, my);
            ctx.strokeStyle = 'rgba(80,255,220,0.15)'; ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                let y = i * h / 5; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                let x = i * w / 5; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
            }
            ctx.fillStyle = 'rgba(80,255,220,0.8)'; ctx.font = '10px Courier New'; ctx.fillText('EARTH ENV', 0, -5);
            const keys = Object.keys(earthEnvData);
            ctx.beginPath(); let f = true;
            keys.forEach((k, i) => {
                let v = earthEnvData[k];
                if (k.includes('pm')) v /= 100; else if (k.includes('aqi')) v /= 200; else if (k === 'co') v /= 1; else if (k === 'uv') v /= 10; else if (k === 'humidity') v /= 100; else if (k === 'visibility') v /= 30;
                v = Math.max(0, Math.min(1, v));
                const x = i * (w / (keys.length - 1)); const y = h - v * h;
                f ? ctx.moveTo(x, y) : ctx.lineTo(x, y); f = false;
            });
            ctx.strokeStyle = 'rgba(80,255,220,0.7)'; ctx.lineWidth = 1.8; ctx.stroke();
            keys.forEach((k, i) => {
                let v = earthEnvData[k];
                if (k.includes('pm')) v /= 100; else if (k.includes('aqi')) v /= 200; else if (k === 'co') v /= 1; else if (k === 'uv') v /= 10; else if (k === 'humidity') v /= 100; else if (k === 'visibility') v /= 30;
                v = Math.max(0, Math.min(1, v));
                const x = i * (w / (keys.length - 1)); const y = h - v * h;
                ctx.beginPath(); ctx.arc(x, y, 3, 0, 6.28); ctx.fillStyle = 'rgba(80,255,220,0.9)'; ctx.fill();
            });
            ctx.restore();
        }

        function drawSystemTopology() {
            const r = Math.min(canvas.width, canvas.height) * 0.16;
            const cx = canvas.width / 2 + (canvas.width > 900 ? 50 : 0);
            const cy = canvas.height / 2;
            ctx.save(); ctx.translate(cx, cy);
            ctx.strokeStyle = 'rgba(0, 180, 255, 0.15)'; ctx.lineWidth = 1;
            [0.3, 0.6, 1.0].forEach(rr => { ctx.beginPath(); ctx.arc(0, 0, r * rr, 0, 6.28); ctx.stroke(); });
            const keys = [{ k: 'seismic', l: 'SEISMIC' }, { k: 'magnetic', l: 'MAGNETIC' }, { k: 'solar_wind', l: 'SOL.WIND' }, { k: 'atmosphere_temp', l: 'TEMP' }, { k: 'air_quality_aqi', l: 'AQI', src: earthEnvData, max: 200 }, { k: 'precipitation', l: 'RAIN' }, { k: 'chaos', l: 'CHAOS' }, { k: 'solar_radiation', l: 'SOL.RAD' }];
            const step = 6.28 / keys.length;
            ctx.beginPath();
            keys.forEach((d, i) => {
                let v = (d.src ? d.src[d.k] : realData[d.k]) || 0; if (d.max) v /= d.max; v = Math.max(0.1, Math.min(1, v));
                const rr = (v + Math.sin(t * 2 + i) * 0.05 * realData.chaos) * r;
                const a = i * step - 1.57; const x = Math.cos(a) * rr, y = Math.sin(a) * rr;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            });
            ctx.closePath(); ctx.fillStyle = 'rgba(255, 100, 50, 0.15)'; ctx.fill(); ctx.strokeStyle = 'rgba(255, 100, 50, 0.8)'; ctx.lineWidth = 2; ctx.stroke();
            keys.forEach((d, i) => {
                let v = (d.src ? d.src[d.k] : realData[d.k]) || 0; if (d.max) v /= d.max; v = Math.max(0.1, Math.min(1, v));
                const rr = (v + Math.sin(t * 2 + i) * 0.05 * realData.chaos) * r;
                const a = i * step - 1.57; const x = Math.cos(a) * rr, y = Math.sin(a) * rr;
                ctx.beginPath(); ctx.arc(x, y, 3, 0, 6.28); ctx.fillStyle = '#fff'; ctx.fill();
                if (canvas.width > 550) {
                    ctx.fillStyle = 'rgba(0, 200, 255, 0.8)'; ctx.font = '9px Courier New'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(d.l, Math.cos(a) * (r + 20), Math.sin(a) * (r + 20));
                }
            });
            ctx.restore();
        }

        function drawStressGrids() {
            if (canvas.width < 900) return;
            const w = 180; // Same width as other graphs
            const mx = canvas.width - w - 20; // Aligned with graphs on the right
            const my = 500; // Positioned under the Earth Env graph
            ctx.save(); ctx.translate(mx, my);

            ctx.fillStyle = 'rgba(0,170,255,0.8)'; ctx.font = '10px Courier New';
            ctx.fillText('SECTOR STRESS INDEX', 0, -10);

            const sectors = [
                { l: 'GEOSPHERE', v: realData.seismic },
                { l: 'MAGNETOSPHERE', v: realData.magnetic },
                { l: 'ATMOSPHERE', v: realData.atmosphere_wind },
                { l: 'BIOSPHERE', v: earthEnvData.air_quality_aqi / 200 },
                { l: 'HELIOSPHERE', v: realData.solar_wind },
                { l: 'STABILITY', v: 1 - realData.chaos }
            ];

            sectors.forEach((s, i) => {
                const y = i * 20;
                const val = Math.max(0.05, Math.min(1, s.v));

                // Label
                ctx.fillStyle = 'rgba(100,200,255,0.6)'; ctx.font = '8px Courier New';
                ctx.fillText(s.l, 0, y + 8);

                // Bar Bg
                ctx.fillStyle = 'rgba(0,40,60,0.4)';
                ctx.fillRect(0, y + 10, w, 4);

                // Bar Fill
                const color = s.v > 0.7 ? 'rgba(255,50,50,0.8)' : (s.v > 0.4 ? 'rgba(255,200,50,0.8)' : 'rgba(0,255,150,0.8)');
                ctx.fillStyle = color;
                ctx.fillRect(0, y + 10, w * val, 4);

                // Value text
                ctx.fillStyle = color;
                ctx.fillText((val * 100).toFixed(0) + '%', w + 5, y + 14);
            });

            ctx.restore();
        }

        let t = 0;
        function loop() {
            t += 0.016;
            ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            const chaos = realData.chaos, cx = canvas.width / 2, cy = canvas.height / 2;
            stars.forEach(s => {
                const tw = Math.sin(t * s.twinkle * 12 + s.x * 0.008) * 0.18 * (1 - chaos * 0.3);
                ctx.fillStyle = `rgba(220,235,255,${Math.max(0.08, s.baseAlpha + tw).toFixed(3)})`;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            });
            if (t % 3 < 2.9) {
                ctx.strokeStyle = 'rgba(180,100,255,0.03)';
                for (let gx = 0; gx < canvas.width; gx += 40) {
                    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
                }
            }
            for (let s = 0; s < 4; s++) {
                ctx.beginPath();
                for (let i = 0; i < 90; i++) {
                    const angle = i * 0.2 + t * 0.5 + s;
                    const radius = i * 0.5 + 25 * Math.sin(t * 0.5 + i * 0.3) + realData.solar_radiation * 20;
                    const x = cx + Math.cos(angle + s) * radius, y = cy + Math.sin(angle + s) * radius;
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }
                ctx.strokeStyle = `rgba(255,${100 + s * 40},${50 + s * 30},${0.05 + realData.solar_wind * 0.15})`;
                ctx.lineWidth = 1 + s * 0.5; ctx.stroke();
            }
            formulaObjs.forEach(f => {
                f.alpha = Math.sin(t * 0.5 + f.phase) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(180,255,200,${f.alpha * 0.25})`;
                ctx.font = '16px Courier New'; ctx.fillText(f.text, f.x + Math.sin(t + f.phase) * 20, f.y + Math.cos(t + f.phase) * 15);
            });
            drawCombinedGrid(); drawSolarGrid(); drawEarthEnvGrid(); drawSystemTopology();
            drawStressGrids(); // New added grid

            const avg = blobs.reduce((s, b) => s + (realData[b.param] || 0.5), 0) / blobs.length;
            blobs.forEach(b => {
                b.currentSize = lerp(b.currentSize, b.targetSize, 0.04 + chaos * 0.1);
                b.currentAlpha = lerp(b.currentAlpha, b.targetAlpha, 0.05 + chaos * 0.12);
                b.currentDist = lerp(b.currentDist, b.radius + (realData[b.param] || 0) * 40, 0.04 + chaos * 0.08);
                const pulse = Math.sin(t * 0.7 + b.phase) * 0.15;
                b.angle += (0.006 + avg * 0.02) * (1 + pulse * 0.3);
                const x = cx + Math.cos(b.angle) * b.currentDist, y = cy + Math.sin(b.angle) * b.currentDist;
                ctx.fillStyle = b.color + b.currentAlpha.toFixed(2) + ')';
                ctx.beginPath(); ctx.arc(x, y, b.currentSize * (1 + pulse), 0, 6.28); ctx.fill();
            });
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>

</html>

<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS.ARHIVE.2026 lavanda audit ibonarium project 2026</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html, body {
  margin:0;
  padding:0;
  background:#000;
  overflow:hidden;
  height:100%;
  font-family:'Courier New', monospace;
  color:#0af;
}
canvas { display:block; }

#hud {
  position:absolute;
  top:16px;
  left:16px;
  font-size:13px;
  opacity:0.7;
  pointer-events:none;
  letter-spacing:1px;
  z-index:10;
}

#data {
  position:absolute;
  top:50px;
  left:16px;
  font-size:10px;
  opacity:0.6;
  pointer-events:none;
  max-width:400px;
  line-height:1.4;
  z-index: 5;
}

#data .real { color:#0f0; font-weight:bold; }
#data .fallback { color:#888; }
#data .warning { color:#ff0; }

#clock {
  position:absolute;
  bottom:16px;
  right:16px;
  font-size:11px;
  opacity:0.45;
  color:#6cf;
  text-align:right;
  pointer-events:none;
  line-height:1.3;
  z-index:10;
}

#status {
  position:absolute;
  top:40px;
  left:16px;
  font-size:11px;
  opacity:0.6;
  color:#0af;
  z-index: 5;
}
  
/* Додано: system1 внизу по центру */
#system-link {
  position: fixed;
  bottom: 60px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 22px;
  color: #0af;
  opacity: 0.75;
  cursor: pointer;
  z-index: 12;
  text-decoration: underline;
  letter-spacing: 1px;
  transition: all 0.3s;
}

#system-link:hover {
  opacity: 1;
  color: #0ff;
  text-shadow: 0 0 12px #0ff;
}
</style>
</head>
<body>

<div id="section-number"></div>

<div id="hud">GEOMETRIC CHAOS.lavanda audit.ibonarium.project.2026.ARHIVE</div>
<div id="status"></div>
<div id="data">ініціалізація...</div>
<div id="clock">—</div>

<div id="system-link">february.2026</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dataDiv = document.getElementById('data');
const clockDiv = document.getElementById('clock');
const statusDiv = document.getElementById('status');

function resize() { 
  canvas.width = window.innerWidth; 
  canvas.height = window.innerHeight; 
}
window.addEventListener('resize', resize); 
resize();

const startTime = Date.now();

function formatRelativeTime(ms) {
  const s = Math.floor(ms / 1000);
  if (s < 60) return `+${s}s`;
  const m = Math.floor(s / 60); const sec = s % 60;
  if (m < 60) return `+${m}m ${sec}s`;
  const h = Math.floor(m / 60); const min = m % 60;
  return `+${h}h ${min}m`;
}

function updateClock() {
  const now = new Date();
  clockDiv.innerHTML = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}<br>${formatRelativeTime(Date.now() - startTime)}`;
}
setInterval(updateClock, 1000); 
updateClock();

// Зірки
const stars = [];
for (let i = 0; i < 300; i++) {
  stars.push({
    x: Math.random()*canvas.width, 
    y: Math.random()*canvas.height, 
    size: Math.random()*1.2+0.4, 
    baseAlpha: Math.random()*0.4+0.25, 
    twinkle: Math.random()*0.015+0.006
  });
}

// Дані
let realData = {seismic:0.5,magnetic:0.5,atmosphere_wind:0.5,atmosphere_pressure:0.5,atmosphere_temp:0.5,ocean:0.5,solar_radiation:0.5,solar_wind:0.5,precipitation:0.5,chaos:0.5};
let dataHistory = {}; Object.keys(realData).forEach(k=>dataHistory[k]=[]);
let sources = {};
let solarIndices = {f107:120,kp:2.0,ap:12,dst:-15,ssn:85,xray:-6.5,proton:0.3,electron:150,bz:-2.5,density:5.2};
let solarHistory = {}; Object.keys(solarIndices).forEach(k=>solarHistory[k]=[]);
let earthEnvData = {air_quality_pm25:15,air_quality_aqi:45,co:0.4,no2:25,o3:40,so2:10,uv_index:3.5,humidity:65,cloud_cover:45,visibility:12};
let earthEnvHistory = {}; Object.keys(earthEnvData).forEach(k=>earthEnvHistory[k]=[]);

const blobs = [
  {param:'seismic',color:'rgba(220,60,80,',phase:0,targetSize:6,targetAlpha:0.75},
  {param:'magnetic',color:'rgba(60,180,255,',phase:1.2,targetSize:6,targetAlpha:0.75},
  {param:'atmosphere_wind',color:'rgba(80,255,160,',phase:2.4,targetSize:6,targetAlpha:0.7},
  {param:'atmosphere_temp',color:'rgba(255,180,60,',phase:3.6,targetSize:6,targetAlpha:0.7},
  {param:'solar_radiation',color:'rgba(255,240,100,',phase:4.8,targetSize:5,targetAlpha:0.65},
  {param:'solar_wind',color:'rgba(200,120,255,',phase:6.0,targetSize:6,targetAlpha:0.7},
  {param:'precipitation',color:'rgba(100,220,255,',phase:7.2,targetSize:6,targetAlpha:0.7}
];
blobs.forEach(b=>{
  b.angle=Math.random()*Math.PI*2;
  b.radius=60+Math.random()*50;
  b.currentSize=b.targetSize;
  b.currentAlpha=b.targetAlpha;
  b.currentDist=b.radius;
});

function lerp(a,b,t){return a+(b-a)*t;}

// Fetch даних
async function fetchRealPlanetData(){
  statusDiv.innerHTML='оновлення...'; 
  let loaded=0;
  const proxy='https://corsproxy.io/?';
  try{
    const weatherUrl='https://api.open-meteo.com/v1/forecast?latitude=50.45&longitude=30.52&current=temperature_2m,relative_humidity_2m,precipitation,cloud_cover,wind_speed_10m,surface_pressure,shortwave_radiation,uv_index,visibility';
    const wRes=await fetch(weatherUrl);
    if(wRes.ok){
      const w=(await wRes.json()).current||{};
      realData.atmosphere_temp=Math.min(1,Math.max(0,(w.temperature_2m+40)/80));
      realData.atmosphere_wind=Math.min(1,(w.wind_speed_10m||0)/80);
      realData.atmosphere_pressure=Math.min(1,Math.max(0,((w.surface_pressure||1013)-950)/150));
      realData.precipitation=Math.min(1,(w.precipitation||0)/15);
      realData.solar_radiation=Math.min(1,(w.shortwave_radiation||0)/1200);
      earthEnvData.humidity=w.relative_humidity_2m||65;
      earthEnvData.cloud_cover=w.cloud_cover||45;
      earthEnvData.uv_index=w.uv_index||3.5;
      earthEnvData.visibility=(w.visibility||12000)/1000;
      loaded++; sources.weather=true;
    }

    const airUrl='https://air-quality-api.open-meteo.com/v1/air-quality?latitude=50.45&longitude=30.52&current=pm2_5,carbon_monoxide,nitrogen_dioxide,sulphur_dioxide,ozone';
    const airRes=await fetch(airUrl);
    if(airRes.ok){
      const a=(await airRes.json()).current||{};
      earthEnvData.air_quality_pm25=a.pm2_5||15;
      earthEnvData.co=a.carbon_monoxide||0.4;
      earthEnvData.no2=a.nitrogen_dioxide||25;
      earthEnvData.o3=a.ozone||40;
      earthEnvData.so2=a.sulphur_dioxide||10;
      earthEnvData.air_quality_aqi=Math.min(500,Math.max(0,earthEnvData.air_quality_pm25*3+earthEnvData.o3/5));
      loaded++; sources.air_quality=true;
    }

    const eqUrl='https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson';
    const eqRes=await fetch(eqUrl);
    if(eqRes.ok){
      const eq=await eqRes.json();
      const feats=eq.features||[]; const count=feats.length;
      const maxMag=feats.reduce((m,f)=>Math.max(m,f.properties?.mag||0),0);
      realData.seismic=Math.min(1,(count/30)+(maxMag/10)*0.5);
      sources.seismic=true; loaded++;
    }

    try{
      const solarRes=await fetch(proxy+encodeURIComponent('https://services.swpc.noaa.gov/products/solar-wind/plasma-7-day.json'));
      if(solarRes.ok){
        const data=await solarRes.json();
        const latest=data[data.length-1]||[];
        const speed=parseFloat(latest[3])||400;
        realData.solar_wind=Math.min(1,Math.max(0,(speed-250)/750));
        sources.solar_wind=true; loaded++;
      }
    }catch(e){console.warn('Solar wind failed',e);}

    try{
      const kpRes=await fetch(proxy+encodeURIComponent('https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json'));
      if(kpRes.ok){
        const data=await kpRes.json();
        const latest=data[data.length-1]||{};
        const kp=parseFloat(latest.kp||latest[1])||2.0;
        realData.magnetic=Math.min(1,kp/9);
        sources.magnetic=true; loaded++;
      }
    }catch(e){console.warn('Kp failed',e);}

    Object.keys(realData).forEach(k=>{if(k!=='chaos'){dataHistory[k].push(realData[k]);if(dataHistory[k].length>80)dataHistory[k].shift();}});
    let vars=[]; 
    Object.keys(dataHistory).forEach(k=>{
      if(k==='chaos') return; 
      const h=dataHistory[k];
      if(h.length<2) return; 
      const mean=h.reduce((a,b)=>a+b,0)/h.length;
      const varnce=h.reduce((a,b)=>a+(b-mean)**2,0)/h.length;
      vars.push(Math.sqrt(varnce));
    });
    realData.chaos=vars.length?Math.min(1,vars.reduce((a,b)=>a+b,0)/vars.length*10):0.5;

    blobs.forEach(b=>{
      const v=realData[b.param]||0.5;
      b.targetSize=4+v*14;
      b.targetAlpha=0.3+v*0.6;
      b.targetDist=70+v*80;
    });

    let html='';
    Object.keys(realData).forEach(k=>{
      let cls='fallback';
      if(sources[k]||k==='chaos') cls='real';
      else if(k!=='chaos') cls='warning';
      html+=`${k.padEnd(20,' ')} <span class="${cls}">${realData[k].toFixed(3)}</span><br>`;
    });
    html+='<br>--- Сонячні індекси ---<br>';
    Object.keys(solarIndices).forEach(k=>{
      html+=`${k.padEnd(20,' ')} <span class="real">${solarIndices[k].toFixed(2)}</span><br>`;
    });
    html+='<br>--- Якість повітря / Погода ---<br>';
    Object.keys(earthEnvData).forEach(k=>{
      let cls=sources.air_quality||sources.weather?'real':'warning';
      html+=`${k.padEnd(20,' ')} <span class="${cls}">${earthEnvData[k].toFixed(2)}</span><br>`;
    });
    dataDiv.innerHTML=html;
    statusDiv.innerHTML=loaded>0?'оновлено':'';
  }catch(e){
    console.error(e);
    statusDiv.innerHTML='';
  }
}
fetchRealPlanetData();
setInterval(fetchRealPlanetData,60000);

// ── функції малювання графіків (без змін) ──

function drawCombinedGrid(){
  const margin=16, width=180, height=120;
  ctx.save();
  ctx.translate(margin,120);
  ctx.strokeStyle='rgba(180,180,180,0.2)'; ctx.lineWidth=1;
  for(let i=0;i<=5;i++){
    const y=i*height/5;
    ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(width,y);ctx.stroke();
  }
  for(let i=0;i<=5;i++){
    const x=i*width/5;
    ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,height);ctx.stroke();
  }
  // Лінія 1 — Основні дані
  ctx.beginPath(); let f1=true;
  Object.keys(realData).forEach((k,i)=>{if(k==='chaos')return; const val=realData[k]; const x=i*(width/(Object.keys(realData).length-1)); const y=height-val*height;
    f1?ctx.moveTo(x,y):ctx.lineTo(x,y); f1=false;});
  ctx.strokeStyle='rgba(0,255,180,0.7)'; ctx.lineWidth=1.5; ctx.stroke();
  // Лінія 2 — Сонячні
  ctx.beginPath(); let f2=true;
  Object.keys(solarIndices).forEach((k,i)=>{let val=solarIndices[k];
    if(k==='f107')val=Math.min(1,val/300);else if(k==='kp')val=val/9;else if(k==='ap')val=Math.min(1,val/400);
    else if(k==='dst')val=Math.min(1,Math.max(0,(val+200)/400));else if(k==='ssn')val=Math.min(1,val/300);
    else if(k==='xray')val=Math.min(1,(val+8)/10);else if(k==='proton'||k==='electron')val=Math.min(1,Math.log10(val+1)/3);
    else if(k==='bz')val=Math.min(1,Math.max(0,(val+20)/40));else if(k==='density')val=Math.min(1,val/50);
    const x=i*(width/(Object.keys(solarIndices).length-1)); const y=height-val*height;
    f2?ctx.moveTo(x,y):ctx.lineTo(x,y); f2=false;});
  ctx.strokeStyle='rgba(255,220,80,0.7)'; ctx.lineWidth=1.5; ctx.stroke();
  // Лінія 3 — Повітря/погода
  ctx.beginPath(); let f3=true;
  Object.keys(earthEnvData).forEach((k,i)=>{let val=earthEnvData[k];
    if(k.includes('pm25'))val=Math.min(1,val/100);else if(k==='air_quality_aqi')val=Math.min(1,val/500);
    else if(k==='co')val=Math.min(1,val/10);else if(k==='no2'||k==='o3'||k==='so2')val=Math.min(1,val/200);
    else if(k==='uv_index')val=Math.min(1,val/12);else if(k==='humidity'||k==='cloud_cover')val=val/100;
    else if(k==='visibility')val=Math.min(1,val/30);
    const x=i*(width/(Object.keys(earthEnvData).length-1)); const y=height-val*height;
    f3?ctx.moveTo(x,y):ctx.lineTo(x,y); f3=false;});
  ctx.strokeStyle='rgba(80,255,220,0.7)'; ctx.lineWidth=1.5; ctx.stroke();
  ctx.restore();
}

function drawLeftGrid(){
  const margin=16,width=180,height=120;
  ctx.save(); ctx.translate(margin,120+height+20);
  ctx.strokeStyle='rgba(0,180,255,0.3)'; ctx.lineWidth=1;
  for(let i=0;i<=5;i++){const y=i*height/5;ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(width,y);ctx.stroke();}
  for(let i=0;i<=5;i++){const x=i*width/5;ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,height);ctx.stroke();}
  const keys=Object.keys(realData);
  ctx.beginPath();let f=true;
  keys.forEach((k,i)=>{const val=realData[k];const x=i*(width/(keys.length-1));const y=height-val*height;
    f?ctx.moveTo(x,y):ctx.lineTo(x,y);f=false;});
  ctx.strokeStyle='rgba(0,255,180,0.6)';ctx.lineWidth=2;ctx.stroke();
  keys.forEach((k,i)=>{const val=realData[k];const x=i*(width/(keys.length-1));const y=height-val*height;
    ctx.beginPath();ctx.arc(x,y,3,0,Math.PI*2);ctx.fillStyle='rgba(0,255,180,0.9)';ctx.fill();});
  ctx.restore();
}

function drawSolarGrid(){
  const margin=16,width=180,height=120;
  ctx.save(); ctx.translate(margin,120+(height+20)*2);
  ctx.strokeStyle='rgba(255,180,0,0.3)';ctx.lineWidth=1;
  for(let i=0;i<=5;i++){const y=i*height/5;ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(width,y);ctx.stroke();}
  for(let i=0;i<=5;i++){const x=i*width/5;ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,height);ctx.stroke();}
  const keys=Object.keys(solarIndices);
  ctx.beginPath();let f=true;
  keys.forEach((k,i)=>{let val=solarIndices[k];
    if(k==='f107')val=Math.min(1,val/300);else if(k==='kp')val=val/9;else if(k==='ap')val=Math.min(1,val/400);
    else if(k==='dst')val=Math.min(1,Math.max(0,(val+200)/400));else if(k==='ssn')val=Math.min(1,val/300);
    else if(k==='xray')val=Math.min(1,(val+8)/10);else if(k==='proton'||k==='electron')val=Math.min(1,Math.log10(val+1)/3);
    else if(k==='bz')val=Math.min(1,Math.max(0,(val+20)/40));else if(k==='density')val=Math.min(1,val/50);
    const x=i*(width/(keys.length-1));const y=height-val*height;
    f?ctx.moveTo(x,y):ctx.lineTo(x,y);f=false;});
  ctx.strokeStyle='rgba(255,220,80,0.7)';ctx.lineWidth=2;ctx.stroke();
  keys.forEach((k,i)=>{let val=solarIndices[k];
    if(k==='f107')val=Math.min(1,val/300);else if(k==='kp')val=val/9;
    const x=i*(width/(keys.length-1));const y=height-val*height;
    ctx.beginPath();ctx.arc(x,y,3,0,Math.PI*2);ctx.fillStyle='rgba(255,220,80,0.9)';ctx.fill();});
  ctx.restore();
}

function drawEarthEnvGrid(){
  const margin=16,width=180,height=120;
  ctx.save(); ctx.translate(margin,120+(height+20)*3);
  ctx.strokeStyle='rgba(0,255,120,0.3)';ctx.lineWidth=1;
  for(let i=0;i<=5;i++){const y=i*height/5;ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(width,y);ctx.stroke();}
  for(let i=0;i<=5;i++){const x=i*width/5;ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,height);ctx.stroke();}
  const keys=Object.keys(earthEnvData);
  ctx.beginPath();let f=true;
  keys.forEach((k,i)=>{let val=earthEnvData[k];
    if(k.includes('pm25'))val=Math.min(1,val/100);else if(k==='air_quality_aqi')val=Math.min(1,val/500);
    else if(k==='co')val=Math.min(1,val/10);else if(k==='no2'||k==='o3'||k==='so2')val=Math.min(1,val/200);
    else if(k==='uv_index')val=Math.min(1,val/12);else if(k==='humidity'||k==='cloud_cover')val=val/100;
    else if(k==='visibility')val=Math.min(1,val/30);
    const x=i*(width/(keys.length-1));const y=height-val*height;
    f?ctx.moveTo(x,y):ctx.lineTo(x,y);f=false;});
  ctx.strokeStyle='rgba(0,255,120,0.7)';ctx.lineWidth=2;ctx.stroke();
  keys.forEach((k,i)=>{let val=earthEnvData[k];
    if(k.includes('pm25'))val=Math.min(1,val/100);
    const x=i*(width/(keys.length-1));const y=height-val*height;
    ctx.beginPath();ctx.arc(x,y,3,0,Math.PI*2);ctx.fillStyle='rgba(0,255,120,0.9)';ctx.fill();});
  ctx.restore();
}

// Формули
const formulas=["E=mc^2","F=ma","∇·E=ρ/ε₀","∫F·dr=ΔK","a^2+b^2=c^2","iħ∂ψ/∂t=Hψ","V=IR"];
const formulaObjs=formulas.map(f=>({text:f,x:Math.random()*window.innerWidth,y:Math.random()*window.innerHeight,alpha:0,phase:Math.random()*Math.PI*2}));

// Анімація
let t=0;
function loop(){
  t+=0.016;
  ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const chaos=realData.chaos, cx=canvas.width/2, cy=canvas.height/2;
  const starMod=1-chaos*0.3;
  stars.forEach(s=>{
    const tw=Math.sin(t*s.twinkle*12+s.x*0.008)*0.18*starMod;
    ctx.fillStyle=`rgba(220,235,255,${Math.max(0.08,s.baseAlpha+tw).toFixed(3)})`;
    ctx.fillRect(s.x,s.y,s.size,s.size);
  });
  const gridSpacing=30;
  for(let gx=0;gx<canvas.width;gx+=gridSpacing){
    for(let gy=0;gy<canvas.height;gy+=gridSpacing){
      const offsetX=Math.sin((gx+gy+t*50)*0.02)*15*chaos;
      const offsetY=Math.cos((gx-gy+t*50)*0.02)*15*chaos;
      ctx.beginPath();ctx.moveTo(gx,gy);ctx.lineTo(gx+offsetX,gy+offsetY);
      ctx.strokeStyle='rgba(180,100,255,0.03)';ctx.lineWidth=1;ctx.stroke();
    }
  }
  for(let s=0;s<4;s++){
    ctx.beginPath();
    for(let i=0;i<150;i++){
      const angle=i*0.18+t*0.5+s;
      const radius=i*0.6+30*Math.sin(t*0.5+i*0.3)+realData.solar_radiation*20;
      const x=cx+Math.cos(angle+s)*radius;
      const y=cy+Math.sin(angle+s)*radius;
      i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
    }
    ctx.strokeStyle=`rgba(255,${100+s*40},${50+s*30},${0.05+realData.solar_wind*0.15})`;
    ctx.lineWidth=1+s*0.5; ctx.stroke();
  }
  formulaObjs.forEach(f=>{
    f.alpha=Math.sin(t*0.5+f.phase)*0.5+0.5;
    ctx.fillStyle=`rgba(180,255,200,${f.alpha*0.25})`;
    ctx.font='16px Courier New';
    ctx.fillText(f.text,f.x+Math.sin(t+f.phase)*20,f.y+Math.cos(t+f.phase)*15);
  });

  drawCombinedGrid();
  drawLeftGrid();
  drawSolarGrid();
  drawEarthEnvGrid();

  const avg=blobs.reduce((s,b)=>s+(realData[b.param]||0.5),0)/blobs.length;
  blobs.forEach(b=>{
    b.currentSize=lerp(b.currentSize,b.targetSize,0.04+chaos*0.10);
    b.currentAlpha=lerp(b.currentAlpha,b.targetAlpha,0.05+chaos*0.12);
    b.currentDist=lerp(b.currentDist,b.targetDist,0.04+chaos*0.08);
    const pulse=Math.sin(t*0.7+b.phase)*0.15+Math.sin(t*1.3+b.phase*1.4)*0.09+Math.sin(t*2.1+b.phase*0.7)*0.06*chaos;
    const size=b.currentSize*(1+pulse*(0.4+chaos*0.9));
    b.angle+=(0.008+avg*0.03+chaos*0.04)*(1+pulse*0.3);
    const x=cx+Math.cos(b.angle)*b.currentDist;
    const y=cy+Math.sin(b.angle)*b.currentDist;
    ctx.fillStyle=b.color+(b.currentAlpha+pulse*0.25).toFixed(2)+')';
    ctx.beginPath();ctx.arc(x,y,size,0,Math.PI*2);ctx.fill();
  });

  requestAnimationFrame(loop);
}
loop();

// ── Відкриття посилання при кліку на system1 ──
document.getElementById('system-link').addEventListener('click', () => {
  window.open('https://lavandaaudit.github.io/indicator-100-live-/', '_blank', 'noopener,noreferrer');
});
</script>
</body>
</html>

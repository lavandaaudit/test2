<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS · SMOOTH PULSE</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
  margin:0;
  padding:0;
  background:#000;
  overflow:hidden;
  height:100%;
  font-family:'Courier New', monospace;
  color:#0af;
}

canvas { display:block; }

#hud {
  position:absolute;
  top:16px;
  left:16px;
  font-size:13px;
  opacity:0.7;
  letter-spacing:1px;
  pointer-events:none;
}

#status {
  position:absolute;
  top:40px;
  left:16px;
  font-size:11px;
  opacity:0.6;
  color:#0af;
}

#data {
  position:absolute;
  bottom:56px;
  left:16px;
  font-size:10px;
  opacity:0.6;
  max-width:400px;
  line-height:1.4;
  pointer-events:none;
}

#data .real { color:#0f0; font-weight:bold; }
#data .fallback { color:#888; }
#data .warning { color:#ff0; }

#clock {
  position:absolute;
  bottom:56px;
  right:16px;
  font-size:11px;
  opacity:0.45;
  color:#6cf;
  text-align:right;
  pointer-events:none;
  line-height:1.3;
}

/* system link — піднятий */
#system1 {
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  font-size:11px;
  opacity:0.45;
  color:#0af;
  letter-spacing:1px;
  text-decoration:none;
  cursor:pointer;
  z-index:10;
}
#system1:hover {
  opacity:0.9;
  color:#6cf;
}

/* footer text */
#footerText {
  position:absolute;
  bottom:16px;
  width:100%;
  text-align:center;
  font-size:11px;
  opacity:0.45;
  letter-spacing:1px;
  pointer-events:none;
}
</style>
</head>

<body>

<div id="hud">GEOMETRIC CHAOS — SMOOTH PULSE</div>
<div id="status"></div>
<div id="data">ініціалізація...</div>
<div id="clock">—</div>

<a id="system1" href="https://lavandaaudit.github.io/level1/#" target="_blank">
  system 1
</a>

<div id="footerText">
  ibonarium project 2026 by lavanda.level#2
</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dataDiv = document.getElementById('data');
const clockDiv = document.getElementById('clock');
const statusDiv = document.getElementById('status');

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

/* ===== CLOCK ===== */
const startTime = Date.now();

function formatRelativeTime(ms) {
  const s = Math.floor(ms / 1000);
  if (s < 60) return `+${s}s`;
  const m = Math.floor(s / 60);
  const sec = s % 60;
  if (m < 60) return `+${m}m ${sec}s`;
  const h = Math.floor(m / 60);
  const min = m % 60;
  return `+${h}h ${min}m`;
}

function updateClock() {
  const now = new Date();
  clockDiv.innerHTML =
    `${String(now.getHours()).padStart(2,'0')}:` +
    `${String(now.getMinutes()).padStart(2,'0')}:` +
    `${String(now.getSeconds()).padStart(2,'0')}<br>` +
    `${formatRelativeTime(Date.now() - startTime)}`;
}
setInterval(updateClock, 1000);
updateClock();

/* ===== STARS ===== */
const stars=[];
for(let i=0;i<300;i++){
  stars.push({
    x:Math.random()*canvas.width,
    y:Math.random()*canvas.height,
    size:Math.random()*1.4+0.4,
    baseAlpha:Math.random()*0.4+0.25,
    twinkle:Math.random()*0.015+0.006
  });
}

/* ===== DATA ===== */
let realData={
  seismic:0.5,
  magnetic:0.5,
  atmosphere_wind:0.5,
  atmosphere_pressure:0.5,
  atmosphere_temp:0.5,
  ocean:0.5,
  solar_radiation:0.5,
  solar_wind:0.5,
  precipitation:0.5,
  chaos:0.5
};

let dataHistory={};
Object.keys(realData).forEach(k=>dataHistory[k]=[]);
let sources={};

/* ===== BLOBS ===== */
const blobs=[
 { param:'seismic', color:'rgba(220,60,80,', phase:0.0 },
 { param:'magnetic', color:'rgba(60,180,255,', phase:1.2 },
 { param:'atmosphere_wind', color:'rgba(80,255,160,', phase:2.4 },
 { param:'atmosphere_temp', color:'rgba(255,180,60,', phase:3.6 },
 { param:'solar_radiation', color:'rgba(255,240,100,', phase:4.8 },
 { param:'solar_wind', color:'rgba(200,120,255,', phase:6.0 },
 { param:'precipitation', color:'rgba(100,220,255,', phase:7.2 }
];

blobs.forEach(b=>{
  b.angle=Math.random()*Math.PI*2;
  b.radius=60+Math.random()*50;
  b.currentSize=6;
  b.currentAlpha=0.7;
  b.currentDist=b.radius;
});

/* ===== UTILS ===== */
function lerp(a,b,t){ return a+(b-a)*t; }

/* ===== FETCH REAL DATA ===== */
async function fetchRealPlanetData(){
  statusDiv.innerHTML='оновлення...';
  let loaded=0;

  try{
    const weatherUrl =
      'https://api.open-meteo.com/v1/forecast' +
      '?latitude=50.55&longitude=30.25' +
      '&current=temperature_2m,wind_speed_10m,surface_pressure,precipitation,shortwave_radiation';

    const wRes = await fetch(weatherUrl);
    if(wRes.ok){
      const w=(await wRes.json()).current||{};
      realData.atmosphere_temp = Math.min(1,Math.max(0,(w.temperature_2m+40)/80));
      realData.atmosphere_wind = Math.min(1,(w.wind_speed_10m||0)/80);
      realData.atmosphere_pressure = Math.min(1,Math.max(0,((w.surface_pressure||1013)-950)/150));
      realData.precipitation = Math.min(1,(w.precipitation||0)/15);
      realData.solar_radiation = Math.min(1,(w.shortwave_radiation||0)/1200);
      loaded+=5;
      sources.atmosphere_temp =
      sources.atmosphere_wind =
      sources.atmosphere_pressure =
      sources.precipitation =
      sources.solar_radiation = true;
    }

    const oceanRes = await fetch(
      'https://marine-api.open-meteo.com/v1/marine?latitude=44.5&longitude=34.0&current=wave_height'
    );
    if(oceanRes.ok){
      const o=(await oceanRes.json()).current||{};
      realData.ocean=Math.min(1,(o.wave_height||0)/8);
      loaded++;
      sources.ocean=true;
    }

    const eqRes = await fetch(
      'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson'
    );
    if(eqRes.ok){
      const eq=await eqRes.json();
      const feats=eq.features||[];
      const maxMag=feats.reduce((m,f)=>Math.max(m,f.properties?.mag||0),0);
      realData.seismic=Math.min(1,(feats.length/30)+(maxMag/10)*0.5);
      loaded++;
      sources.seismic=true;
    }

    const proxy='https://corsproxy.io/?';

    try{
      const solarRes=await fetch(
        proxy+encodeURIComponent('https://services.swpc.noaa.gov/products/solar-wind/plasma-7-day.json')
      );
      if(solarRes.ok){
        const d=await solarRes.json();
        const speed=parseFloat(d[d.length-1]?.[3])||400;
        realData.solar_wind=Math.min(1,Math.max(0,(speed-250)/750));
        loaded++;
        sources.solar_wind=true;
      }
    }catch{}

    try{
      const kpRes=await fetch(
        proxy+encodeURIComponent('https://services.swpc.noaa.gov/products/geospace/planetary-k-index-1-minute.json')
      );
      if(kpRes.ok){
        const d=await kpRes.json();
        const kp=parseFloat(d[d.length-1]?.[1])||0;
        realData.magnetic=Math.min(1,kp/9);
        loaded++;
        sources.magnetic=true;
      }
    }catch{}

    Object.keys(realData).forEach(k=>{
      if(k!=='chaos'){
        dataHistory[k].push(realData[k]);
        if(dataHistory[k].length>80) dataHistory[k].shift();
      }
    });

    const vars=[];
    Object.keys(dataHistory).forEach(k=>{
      if(k==='chaos') return;
      const h=dataHistory[k];
      if(h.length<2) return;
      const mean=h.reduce((a,b)=>a+b,0)/h.length;
      const v=h.reduce((a,b)=>a+(b-mean)**2,0)/h.length;
      vars.push(Math.sqrt(v));
    });

    realData.chaos = vars.length
      ? Math.min(1,vars.reduce((a,b)=>a+b,0)/vars.length*10)
      : 0.5;

    blobs.forEach(b=>{
      const v=realData[b.param]||0.5;
      b.targetSize=4+v*14;
      b.targetAlpha=0.3+v*0.6;
      b.targetDist=70+v*80;
    });

    let html='';
    Object.keys(realData).forEach(k=>{
      let cls='fallback';
      if(sources[k]) cls='real';
      else if(k!=='chaos') cls='warning';
      html+=`${k.padEnd(20,' ')} <span class="${cls}">${realData[k].toFixed(3)}</span><br>`;
    });
    dataDiv.innerHTML=html;

    statusDiv.innerHTML=loaded>0?'оновлено':'';
  }catch(e){
    console.error(e);
    statusDiv.innerHTML='';
  }
}

fetchRealPlanetData();
setInterval(fetchRealPlanetData,120000);

/* ===== LOOP ===== */
let t=0;
function loop(){
  t+=0.016;
  ctx.fillStyle='rgba(0,0,0,0.07)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const chaos=realData.chaos;
  const starMod=1-chaos*0.35;

  stars.forEach(s=>{
    const tw=Math.sin(t*s.twinkle*12+s.x*0.008)*0.18*starMod;
    ctx.fillStyle=`rgba(220,235,255,${Math.max(0.08,s.baseAlpha+tw).toFixed(3)})`;
    ctx.fillRect(s.x,s.y,s.size,s.size);
  });

  const cx=canvas.width/2, cy=canvas.height/2;
  const smooth=0.04+chaos*0.10;
  const avg=blobs.reduce((s,b)=>s+(realData[b.param]||0.5),0)/blobs.length;

  blobs.forEach(b=>{
    b.currentSize=lerp(b.currentSize,b.targetSize,smooth);
    b.currentAlpha=lerp(b.currentAlpha,b.targetAlpha,smooth*1.2);
    b.currentDist=lerp(b.currentDist,b.targetDist,smooth*0.8);

    const pulse=
      Math.sin(t*0.7+b.phase)*0.15 +
      Math.sin(t*1.3+b.phase*1.4)*0.09 +
      Math.sin(t*2.1+b.phase*0.7)*0.06*chaos;

    const size=b.currentSize*(1+pulse*(0.4+chaos*0.9));
    b.angle+=(0.008+avg*0.03+chaos*0.04)*(1+pulse*0.3);

    const x=cx+Math.cos(b.angle)*b.currentDist;
    const y=cy+Math.sin(b.angle)*b.currentDist;

    ctx.fillStyle=b.color+(b.currentAlpha+pulse*0.25).toFixed(2)+')';
    ctx.beginPath();
    ctx.arc(x,y,size,0,Math.PI*2);
    ctx.fill();
  });

  const ringBase=110+Math.sin(t*0.25)*18+Math.sin(t*0.48)*12;
  const ringR=ringBase*(1+chaos*0.35+Math.sin(t*0.9)*0.08);

  ctx.beginPath();
  ctx.arc(cx,cy,ringR,0,Math.PI*2);
  ctx.strokeStyle=`rgba(140,240,255,${0.06+chaos*0.18+Math.sin(t*1.1)*0.04})`;
  ctx.lineWidth=1.4+chaos*3.2;
  ctx.stroke();

  const sides = 3; // трикутник як було бажано
  const polyR = ringR*1.2 + realData.solar_radiation*30;

  ctx.beginPath();
  for(let i=0;i<sides;i++){
    const ang=(Math.PI*2/sides)*i+t*0.1;
    const px=cx+Math.cos(ang)*polyR;
    const py=cy+Math.sin(ang)*polyR;
    i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle=`rgba(255,200,100,${0.04+realData.solar_wind*0.1})`;
  ctx.stroke();

  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
